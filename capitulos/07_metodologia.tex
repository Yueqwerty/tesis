\chapter{Diseño e Implementación de la Solución}
\label{chap:implementacion}

La implementación del modelo matemático se realizó construyendo un artefacto de software en Python. Este capítulo detalla la arquitectura computacional, justificando las decisiones de diseño en función de la eficiencia algorítmica y la mantenibilidad del código.

\section{Fundamentación del Stack Tecnológico}

El núcleo del simulador fue construido sobre el ecosistema de \textit{Scientific Python}, una elección respaldada por la literatura técnica como el estándar moderno para la computación científica \cite{Oliphant2007}. Se seleccionaron librerías específicas para optimizar el rendimiento y la precisión:
\begin{itemize}
    \item \textbf{SimPy:} Framework de simulación de eventos discretos basado en generadores. A diferencia de los simuladores basados en \textit{callbacks}, SimPy permite modelar procesos activos de manera intuitiva \cite{SimPy2020}.
    \item \textbf{NumPy:} Motor de cálculo numérico optimizado en C, utilizado para la generación eficiente de variables aleatorias de alta calidad estadística \cite{NumPy2020}.
\end{itemize}

\section{Arquitectura de Procesos y Corutinas}

Uno de los desafíos centrales en la simulación de sistemas complejos es la gestión de la concurrencia. El sistema real posee múltiples actores (consumidores, camiones, clima) que operan simultáneamente. Para modelar esto en un entorno de ejecución de un solo hilo (\textit{single-threaded}), se utilizó el patrón de diseño de corutinas.

Mediante la palabra clave \texttt{yield} de Python, las funciones del simulador pueden pausar su ejecución y ceder el control al planificador central de eventos. Esto permite modelar procesos concurrentes utilizando concurrencia cooperativa, eliminando la sobrecarga (\textit{overhead}) de cambios de contexto asociados al multihilo tradicional del sistema operativo.

\subsection{Algoritmo de Sincronización}
El proceso de reabastecimiento, por ejemplo, no es un bucle infinito que consume CPU (espera activa), sino un generador que interactúa con el reloj de simulación. El proceso evalúa la condición de inventario y, si el nivel es suficiente, invoca \texttt{yield timeout(1)}, instruyendo al simulador a "dormir" este proceso hasta el siguiente día lógico. Esta técnica optimiza drásticamente el uso de recursos computacionales.

\section{Complejidad Computacional}

El rendimiento del simulador está determinado teóricamente por la eficiencia de las operaciones en la Lista de Eventos Futuros (FEL). Dado que SimPy implementa esta lista mediante un montículo binario (\textit{min-heap}), el costo de procesar una simulación de $N$ eventos es de orden $O(N \log M)$, donde $M$ es el número promedio de eventos pendientes en la cola.

En el contexto de este proyecto, el número de eventos concurrentes se mantiene acotado (proporcional al número de camiones en tránsito), lo que garantiza que el tiempo de ejecución crezca de manera casi lineal con la duración de la simulación. Esta eficiencia algorítmica es la propiedad fundamental que viabiliza la ejecución del experimento de Monte Carlo con 100.000 iteraciones en tiempos de cómputo reducidos.

\section{Aseguramiento de Calidad (QA)}

Siguiendo las prácticas de ingeniería de software modernas, se implementó una estrategia de validación basada en pruebas automatizadas. Se verificaron los invariantes físicos del sistema mediante aserciones lógicas. Específicamente, se comprueba la ley de conservación de masa:
\begin{equation}
    \sum \text{Entradas} - \sum \text{Salidas} = \Delta \text{Inventario}
\end{equation}
La validación estricta de esta igualdad al final de cada ejecución asegura que no existen errores de lógica en la manipulación de las variables de estado compartidas, garantizando la integridad de los datos generados.
